/* tslint:disable */
/* eslint-disable */
/**
 * Qore Data
 * qore-engine api docs
 *
 * The version of the OpenAPI document: 1.0.80
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig
} from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError
} from "./base";

/**
 *
 * @export
 * @interface Authorize200Response
 */
export interface Authorize200Response {
  /**
   *
   * @type {string}
   * @memberof Authorize200Response
   */
  token: string;
}
/**
 *
 * @export
 * @interface AuthorizeRequest
 */
export interface AuthorizeRequest {
  /**
   *
   * @type {string}
   * @memberof AuthorizeRequest
   */
  identifier: string;
  /**
   *
   * @type {string}
   * @memberof AuthorizeRequest
   */
  password?: string | null;
}
/**
 * Resource Not Found
 * @export
 * @interface CreateRow404Response
 */
export interface CreateRow404Response {
  /**
   *
   * @type {number}
   * @memberof CreateRow404Response
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof CreateRow404Response
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof CreateRow404Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface Execute200Response
 */
export interface Execute200Response {
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof Execute200Response
   */
  results: { [key: string]: any };
}
/**
 *
 * @export
 * @interface ExecuteRequest
 */
export interface ExecuteRequest {
  /**
   *
   * @type {Array<ExecuteRequestOperationsInner>}
   * @memberof ExecuteRequest
   */
  operations: Array<ExecuteRequestOperationsInner>;
}
/**
 *
 * @export
 * @interface ExecuteRequestOperationsInner
 */
export interface ExecuteRequestOperationsInner {
  /**
   *
   * @type {string}
   * @memberof ExecuteRequestOperationsInner
   */
  operation: ExecuteRequestOperationsInnerOperationEnum;
  /**
   *
   * @type {object}
   * @memberof ExecuteRequestOperationsInner
   */
  instruction: object;
}

export const ExecuteRequestOperationsInnerOperationEnum = {
  Delete: "Delete",
  Insert: "Insert",
  Select: "Select",
  Update: "Update",
  AddRelation: "AddRelation",
  RemoveRelation: "RemoveRelation",
  Aggregate: "Aggregate",
  Insight: "Insight"
} as const;

export type ExecuteRequestOperationsInnerOperationEnum = typeof ExecuteRequestOperationsInnerOperationEnum[keyof typeof ExecuteRequestOperationsInnerOperationEnum];

/**
 *
 * @export
 * @interface GetAllRolesAndPermissions200Response
 */
export interface GetAllRolesAndPermissions200Response {
  /**
   *
   * @type {Array<{ [key: string]: any; }>}
   * @memberof GetAllRolesAndPermissions200Response
   */
  roles: Array<{ [key: string]: any }>;
}
/**
 *
 * @export
 * @interface GetMigrations200Response
 */
export interface GetMigrations200Response {
  /**
   *
   * @type {Array<GetMigrations200ResponseItemsInner>}
   * @memberof GetMigrations200Response
   */
  items: Array<GetMigrations200ResponseItemsInner>;
  /**
   *
   * @type {GetMigrations200ResponsePagination}
   * @memberof GetMigrations200Response
   */
  pagination: GetMigrations200ResponsePagination;
}
/**
 *
 * @export
 * @interface GetMigrations200ResponseItemsInner
 */
export interface GetMigrations200ResponseItemsInner {
  /**
   *
   * @type {number}
   * @memberof GetMigrations200ResponseItemsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof GetMigrations200ResponseItemsInner
   */
  name: string;
  /**
   *
   * @type {boolean}
   * @memberof GetMigrations200ResponseItemsInner
   */
  active: boolean;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetMigrations200ResponseItemsInner
   */
  schema: { [key: string]: any };
  /**
   *
   * @type {string}
   * @memberof GetMigrations200ResponseItemsInner
   */
  up: string;
  /**
   *
   * @type {string}
   * @memberof GetMigrations200ResponseItemsInner
   */
  down: string;
  /**
   *
   * @type {number}
   * @memberof GetMigrations200ResponseItemsInner
   */
  createdAt: number;
  /**
   *
   * @type {string}
   * @memberof GetMigrations200ResponseItemsInner
   */
  description?: string | null;
}
/**
 *
 * @export
 * @interface GetMigrations200ResponsePagination
 */
export interface GetMigrations200ResponsePagination {
  /**
   *
   * @type {number}
   * @memberof GetMigrations200ResponsePagination
   */
  limit?: number;
  /**
   *
   * @type {number}
   * @memberof GetMigrations200ResponsePagination
   */
  offset?: number;
  /**
   *
   * @type {number}
   * @memberof GetMigrations200ResponsePagination
   */
  total?: number;
}
/**
 *
 * @export
 * @interface GetRows200Response
 */
export interface GetRows200Response {
  /**
   *
   * @type {Array<{ [key: string]: any; }>}
   * @memberof GetRows200Response
   */
  items: Array<{ [key: string]: any }>;
  /**
   *
   * @type {number}
   * @memberof GetRows200Response
   */
  total_rows?: number;
  /**
   *
   * @type {GetViewRows200ResponsePagination}
   * @memberof GetRows200Response
   */
  pagination: GetViewRows200ResponsePagination;
}
/**
 *
 * @export
 * @interface GetSchema200Response
 */
export interface GetSchema200Response {
  /**
   *
   * @type {Array<GetSchema200ResponseTablesInner>}
   * @memberof GetSchema200Response
   */
  tables: Array<GetSchema200ResponseTablesInner>;
  /**
   *
   * @type {Array<GetSchema200ResponseQueriesInner>}
   * @memberof GetSchema200Response
   */
  queries?: Array<GetSchema200ResponseQueriesInner>;
}
/**
 *
 * @export
 * @interface GetSchema200ResponseQueriesInner
 */
export interface GetSchema200ResponseQueriesInner {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseQueriesInner
   */
  name?: string;
  /**
   *
   * @type {Array<GetSchema200ResponseQueriesInnerColumnsInner>}
   * @memberof GetSchema200ResponseQueriesInner
   */
  columns?: Array<GetSchema200ResponseQueriesInnerColumnsInner>;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseQueriesInner
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseQueriesInner
   */
  query?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetSchema200ResponseQueriesInner
   */
  params?: { [key: string]: any } | null;
}
/**
 *
 * @export
 * @interface GetSchema200ResponseQueriesInnerColumnsInner
 */
export interface GetSchema200ResponseQueriesInnerColumnsInner {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseQueriesInnerColumnsInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseQueriesInnerColumnsInner
   */
  type: string;
}
/**
 *
 * @export
 * @interface GetSchema200ResponseTablesInner
 */
export interface GetSchema200ResponseTablesInner {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInner
   */
  name: string;
  /**
   *
   * @type {Array<GetSchema200ResponseTablesInnerColumnsInner>}
   * @memberof GetSchema200ResponseTablesInner
   */
  columns: Array<GetSchema200ResponseTablesInnerColumnsInner>;
  /**
   *
   * @type {Array<GetSchema200ResponseTablesInnerRolesInner>}
   * @memberof GetSchema200ResponseTablesInner
   */
  roles: Array<GetSchema200ResponseTablesInnerRolesInner>;
  /**
   *
   * @type {Array<GetSchema200ResponseTablesInnerViewsInner>}
   * @memberof GetSchema200ResponseTablesInner
   */
  views: Array<GetSchema200ResponseTablesInnerViewsInner>;
  /**
   *
   * @type {Array<GetSchema200ResponseTablesInnerInsightsInner>}
   * @memberof GetSchema200ResponseTablesInner
   */
  insights: Array<GetSchema200ResponseTablesInnerInsightsInner>;
  /**
   *
   * @type {Array<GetSchema200ResponseTablesInnerTriggersInner>}
   * @memberof GetSchema200ResponseTablesInner
   */
  triggers: Array<GetSchema200ResponseTablesInnerTriggersInner>;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInner
   */
  primaryKey: string;
}
/**
 *
 * @export
 * @interface GetSchema200ResponseTablesInnerColumnsInner
 */
export interface GetSchema200ResponseTablesInnerColumnsInner {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerColumnsInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerColumnsInner
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerColumnsInner
   */
  description?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetSchema200ResponseTablesInnerColumnsInner
   */
  definition?: { [key: string]: any } | null;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetSchema200ResponseTablesInnerColumnsInner
   */
  metadata?: { [key: string]: any } | null;
  /**
   *
   * @type {GetSchema200ResponseTablesInnerColumnsInnerReferences}
   * @memberof GetSchema200ResponseTablesInnerColumnsInner
   */
  references?: GetSchema200ResponseTablesInnerColumnsInnerReferences | null;
  /**
   *
   * @type {boolean}
   * @memberof GetSchema200ResponseTablesInnerColumnsInner
   */
  isHidden?: boolean;
}
/**
 *
 * @export
 * @interface GetSchema200ResponseTablesInnerColumnsInnerReferences
 */
export interface GetSchema200ResponseTablesInnerColumnsInnerReferences {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerColumnsInnerReferences
   */
  targetTable: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerColumnsInnerReferences
   */
  column: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerColumnsInnerReferences
   */
  type?: string;
  /**
   *
   * @type {boolean}
   * @memberof GetSchema200ResponseTablesInnerColumnsInnerReferences
   */
  origin?: boolean;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerColumnsInnerReferences
   */
  onDelete?: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerColumnsInnerReferences
   */
  onUpdate?: string;
}
/**
 *
 * @export
 * @interface GetSchema200ResponseTablesInnerInsightsInner
 */
export interface GetSchema200ResponseTablesInnerInsightsInner {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerInsightsInner
   */
  name: string;
  /**
   *
   * @type {Array<GetSchema200ResponseTablesInnerInsightsInnerColumnsInner>}
   * @memberof GetSchema200ResponseTablesInnerInsightsInner
   */
  columns: Array<GetSchema200ResponseTablesInnerInsightsInnerColumnsInner>;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetSchema200ResponseTablesInnerInsightsInner
   */
  insight: { [key: string]: any };
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetSchema200ResponseTablesInnerInsightsInner
   */
  baseCondition: { [key: string]: any };
  /**
   *
   * @type {Array<{ [key: string]: any; }>}
   * @memberof GetSchema200ResponseTablesInnerInsightsInner
   */
  sorts: Array<{ [key: string]: any }>;
  /**
   *
   * @type {Array<string>}
   * @memberof GetSchema200ResponseTablesInnerInsightsInner
   */
  params?: Array<string>;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetSchema200ResponseTablesInnerInsightsInner
   */
  registeredParams: { [key: string]: any };
}
/**
 *
 * @export
 * @interface GetSchema200ResponseTablesInnerInsightsInnerColumnsInner
 */
export interface GetSchema200ResponseTablesInnerInsightsInnerColumnsInner {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerInsightsInnerColumnsInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerInsightsInnerColumnsInner
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerInsightsInnerColumnsInner
   */
  description?: string;
}
/**
 *
 * @export
 * @interface GetSchema200ResponseTablesInnerRolesInner
 */
export interface GetSchema200ResponseTablesInnerRolesInner {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerRolesInner
   */
  name: string;
  /**
   *
   * @type {Array<GetSchema200ResponseTablesInnerRolesInnerPermissionsInner>}
   * @memberof GetSchema200ResponseTablesInnerRolesInner
   */
  permissions: Array<GetSchema200ResponseTablesInnerRolesInnerPermissionsInner>;
}
/**
 *
 * @export
 * @interface GetSchema200ResponseTablesInnerRolesInnerPermissionsInner
 */
export interface GetSchema200ResponseTablesInnerRolesInnerPermissionsInner {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerRolesInnerPermissionsInner
   */
  action: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetSchema200ResponseTablesInnerRolesInnerPermissionsInner
   */
  condition: { [key: string]: any };
}
/**
 *
 * @export
 * @interface GetSchema200ResponseTablesInnerTriggersInner
 */
export interface GetSchema200ResponseTablesInnerTriggersInner {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerTriggersInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerTriggersInner
   */
  event: string;
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerTriggersInner
   */
  destination?: string;
  /**
   *
   * @type {number}
   * @memberof GetSchema200ResponseTablesInnerTriggersInner
   */
  maxAttempts: number;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetSchema200ResponseTablesInnerTriggersInner
   */
  webhook: { [key: string]: any };
}
/**
 *
 * @export
 * @interface GetSchema200ResponseTablesInnerViewsInner
 */
export interface GetSchema200ResponseTablesInnerViewsInner {
  /**
   *
   * @type {string}
   * @memberof GetSchema200ResponseTablesInnerViewsInner
   */
  name?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetSchema200ResponseTablesInnerViewsInner
   */
  baseCondition?: { [key: string]: any };
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetSchema200ResponseTablesInnerViewsInner
   */
  query?: { [key: string]: any };
  /**
   *
   * @type {Array<{ [key: string]: any; }>}
   * @memberof GetSchema200ResponseTablesInnerViewsInner
   */
  sorts?: Array<{ [key: string]: any }>;
  /**
   *
   * @type {Array<GetSchema200ResponseTablesInnerRolesInner>}
   * @memberof GetSchema200ResponseTablesInnerViewsInner
   */
  roles?: Array<GetSchema200ResponseTablesInnerRolesInner>;
}
/**
 *
 * @export
 * @interface GetTables200Response
 */
export interface GetTables200Response {
  /**
   *
   * @type {GetTables200ResponsePagination}
   * @memberof GetTables200Response
   */
  pagination: GetTables200ResponsePagination;
  /**
   *
   * @type {Array<GetTables200ResponseItemsInner>}
   * @memberof GetTables200Response
   */
  items: Array<GetTables200ResponseItemsInner>;
}
/**
 *
 * @export
 * @interface GetTables200ResponseItemsInner
 */
export interface GetTables200ResponseItemsInner {
  /**
   *
   * @type {string}
   * @memberof GetTables200ResponseItemsInner
   */
  name: string;
  /**
   *
   * @type {Array<GetTables200ResponseItemsInnerColumnsInner>}
   * @memberof GetTables200ResponseItemsInner
   */
  columns: Array<GetTables200ResponseItemsInnerColumnsInner>;
  /**
   *
   * @type {Array<GetTables200ResponseItemsInnerViewsInner>}
   * @memberof GetTables200ResponseItemsInner
   */
  views: Array<GetTables200ResponseItemsInnerViewsInner>;
  /**
   *
   * @type {Array<Array<string>>}
   * @memberof GetTables200ResponseItemsInner
   */
  compositeIndexes?: Array<Array<string>> | null;
  /**
   *
   * @type {string}
   * @memberof GetTables200ResponseItemsInner
   */
  category?: string | null;
}
/**
 *
 * @export
 * @interface GetTables200ResponseItemsInnerColumnsInner
 */
export interface GetTables200ResponseItemsInnerColumnsInner {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof GetTables200ResponseItemsInnerColumnsInner
   */
  fieldType: string;
  /**
   *
   * @type {string}
   * @memberof GetTables200ResponseItemsInnerColumnsInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface GetTables200ResponseItemsInnerViewsInner
 */
export interface GetTables200ResponseItemsInnerViewsInner {
  /**
   *
   * @type {string}
   * @memberof GetTables200ResponseItemsInnerViewsInner
   */
  name: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetTables200ResponseItemsInnerViewsInner
   */
  query: { [key: string]: any };
}
/**
 *
 * @export
 * @interface GetTables200ResponsePagination
 */
export interface GetTables200ResponsePagination {
  /**
   *
   * @type {number}
   * @memberof GetTables200ResponsePagination
   */
  limit?: number;
  /**
   *
   * @type {number}
   * @memberof GetTables200ResponsePagination
   */
  offset?: number;
  /**
   *
   * @type {number}
   * @memberof GetTables200ResponsePagination
   */
  total?: number;
}
/**
 *
 * @export
 * @interface GetViewRows200Response
 */
export interface GetViewRows200Response {
  /**
   *
   * @type {Array<{ [key: string]: any; }>}
   * @memberof GetViewRows200Response
   */
  items: Array<{ [key: string]: any }>;
  /**
   *
   * @type {GetViewRows200ResponsePagination}
   * @memberof GetViewRows200Response
   */
  pagination: GetViewRows200ResponsePagination;
}
/**
 *
 * @export
 * @interface GetViewRows200ResponsePagination
 */
export interface GetViewRows200ResponsePagination {
  /**
   *
   * @type {number}
   * @memberof GetViewRows200ResponsePagination
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof GetViewRows200ResponsePagination
   */
  total: number;
}
/**
 * Unauthorized
 * @export
 * @interface GetViewRows401Response
 */
export interface GetViewRows401Response {
  /**
   *
   * @type {number}
   * @memberof GetViewRows401Response
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof GetViewRows401Response
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof GetViewRows401Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface Migrate200Response
 */
export interface Migrate200Response {
  /**
   *
   * @type {Array<Migrate200ResponseResultsInner>}
   * @memberof Migrate200Response
   */
  results: Array<Migrate200ResponseResultsInner>;
}
/**
 *
 * @export
 * @interface Migrate200ResponseResultsInner
 */
export interface Migrate200ResponseResultsInner {
  /**
   *
   * @type {number}
   * @memberof Migrate200ResponseResultsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof Migrate200ResponseResultsInner
   */
  name: string;
  /**
   *
   * @type {boolean}
   * @memberof Migrate200ResponseResultsInner
   */
  active: boolean;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof Migrate200ResponseResultsInner
   */
  schema: { [key: string]: any };
  /**
   *
   * @type {string}
   * @memberof Migrate200ResponseResultsInner
   */
  up: string;
  /**
   *
   * @type {string}
   * @memberof Migrate200ResponseResultsInner
   */
  down: string;
  /**
   *
   * @type {string}
   * @memberof Migrate200ResponseResultsInner
   */
  description?: string | null;
  /**
   *
   * @type {number}
   * @memberof Migrate200ResponseResultsInner
   */
  createdAt?: number;
}
/**
 *
 * @export
 * @interface MigrateRequest
 */
export interface MigrateRequest {
  /**
   *
   * @type {Array<MigrateRequestOperationsInner>}
   * @memberof MigrateRequest
   */
  operations: Array<MigrateRequestOperationsInner>;
}
/**
 *
 * @export
 * @interface MigrateRequestOperationsInner
 */
export interface MigrateRequestOperationsInner {
  /**
   *
   * @type {string}
   * @memberof MigrateRequestOperationsInner
   */
  operation: MigrateRequestOperationsInnerOperationEnum;
  /**
   *
   * @type {string}
   * @memberof MigrateRequestOperationsInner
   */
  resource: MigrateRequestOperationsInnerResourceEnum;
  /**
   *
   * @type {object}
   * @memberof MigrateRequestOperationsInner
   */
  migration: object;
}

export const MigrateRequestOperationsInnerOperationEnum = {
  Alter: "Alter",
  Create: "Create",
  Drop: "Drop"
} as const;

export type MigrateRequestOperationsInnerOperationEnum = typeof MigrateRequestOperationsInnerOperationEnum[keyof typeof MigrateRequestOperationsInnerOperationEnum];
export const MigrateRequestOperationsInnerResourceEnum = {
  Column: "Column",
  ManyToManyRelation: "ManyToManyRelation",
  OneToManyRelation: "OneToManyRelation",
  Permission: "Permission",
  Role: "Role",
  Table: "Table",
  View: "View",
  Insight: "Insight",
  Trigger: "Trigger",
  Query: "Query"
} as const;

export type MigrateRequestOperationsInnerResourceEnum = typeof MigrateRequestOperationsInnerResourceEnum[keyof typeof MigrateRequestOperationsInnerResourceEnum];

/**
 *
 * @export
 * @interface RawsqlRequest
 */
export interface RawsqlRequest {
  /**
   *
   * @type {string}
   * @memberof RawsqlRequest
   */
  query: string;
}
/**
 *
 * @export
 * @interface Rollback200Response
 */
export interface Rollback200Response {
  /**
   *
   * @type {boolean}
   * @memberof Rollback200Response
   */
  ok: boolean;
}
/**
 *
 * @export
 * @interface RollbackRequest
 */
export interface RollbackRequest {
  /**
   *
   * @type {number}
   * @memberof RollbackRequest
   */
  rollbacks: number;
}
/**
 *
 * @export
 * @interface UploadFile200Response
 */
export interface UploadFile200Response {
  /**
   *
   * @type {string}
   * @memberof UploadFile200Response
   */
  filename: string;
  /**
   *
   * @type {string}
   * @memberof UploadFile200Response
   */
  mimetype: string;
  /**
   *
   * @type {number}
   * @memberof UploadFile200Response
   */
  size: number;
}
/**
 *
 * @export
 * @interface V1VersionGet200Response
 */
export interface V1VersionGet200Response {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof V1VersionGet200Response
   */
  version: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _export: async (
      token: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists("_export", "token", token);
      const localVarPath = `/v1/export`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _export_1: async (
      token: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists("_export_1", "token", token);
      const localVarPath = `/v1/export/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} table
     * @param {string} column
     * @param {string} rowId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    action: async (
      table: string,
      column: string,
      rowId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'table' is not null or undefined
      assertParamExists("action", "table", table);
      // verify required parameter 'column' is not null or undefined
      assertParamExists("action", "column", column);
      // verify required parameter 'rowId' is not null or undefined
      assertParamExists("action", "rowId", rowId);
      const localVarPath = `/v1/action/{table}/{column}/{rowId}`
        .replace(`{${"table"}}`, encodeURIComponent(String(table)))
        .replace(`{${"column"}}`, encodeURIComponent(String(column)))
        .replace(`{${"rowId"}}`, encodeURIComponent(String(rowId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {AuthorizeRequest} authorizeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorize: async (
      authorizeRequest: AuthorizeRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorizeRequest' is not null or undefined
      assertParamExists("authorize", "authorizeRequest", authorizeRequest);
      const localVarPath = `/v1/authorize`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        authorizeRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} table
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRow: async (
      table: string,
      body: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'table' is not null or undefined
      assertParamExists("createRow", "table", table);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("createRow", "body", body);
      const localVarPath = `/v1/table/{table}`.replace(
        `{${"table"}}`,
        encodeURIComponent(String(table))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} token
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (
      token: string,
      filename: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists("deleteFile", "token", token);
      // verify required parameter 'filename' is not null or undefined
      assertParamExists("deleteFile", "filename", filename);
      const localVarPath = `/v1/files/{filename}`.replace(
        `{${"filename"}}`,
        encodeURIComponent(String(filename))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} table
     * @param {string} rowID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRow: async (
      table: string,
      rowID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'table' is not null or undefined
      assertParamExists("deleteRow", "table", table);
      // verify required parameter 'rowID' is not null or undefined
      assertParamExists("deleteRow", "rowID", rowID);
      const localVarPath = `/v1/table/{table}/row/{rowID}`
        .replace(`{${"table"}}`, encodeURIComponent(String(table)))
        .replace(`{${"rowID"}}`, encodeURIComponent(String(rowID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} token
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: async (
      token: string,
      filename: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists("downloadFile", "token", token);
      // verify required parameter 'filename' is not null or undefined
      assertParamExists("downloadFile", "filename", filename);
      const localVarPath = `/v1/files/{filename}`.replace(
        `{${"filename"}}`,
        encodeURIComponent(String(filename))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} filename
     * @param {string} id
     * @param {string} column
     * @param {string} table
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadPublicFile: async (
      filename: string,
      id: string,
      column: string,
      table: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'filename' is not null or undefined
      assertParamExists("downloadPublicFile", "filename", filename);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("downloadPublicFile", "id", id);
      // verify required parameter 'column' is not null or undefined
      assertParamExists("downloadPublicFile", "column", column);
      // verify required parameter 'table' is not null or undefined
      assertParamExists("downloadPublicFile", "table", table);
      const localVarPath = `/v1/files/public/{table}/{id}/{column}/{filename}`
        .replace(`{${"filename"}}`, encodeURIComponent(String(filename)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"column"}}`, encodeURIComponent(String(column)))
        .replace(`{${"table"}}`, encodeURIComponent(String(table)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {ExecuteRequest} executeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    execute: async (
      executeRequest: ExecuteRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'executeRequest' is not null or undefined
      assertParamExists("execute", "executeRequest", executeRequest);
      const localVarPath = `/v1/execute`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        executeRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRolesAndPermissions: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMigrations: async (
      limit?: number,
      offset?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/migrations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} table
     * @param {string} rowID
     * @param {Array<string>} [populate]
     * @param {{ [key: string]: any; }} [condition]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRow: async (
      table: string,
      rowID: string,
      populate?: Array<string>,
      condition?: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'table' is not null or undefined
      assertParamExists("getRow", "table", table);
      // verify required parameter 'rowID' is not null or undefined
      assertParamExists("getRow", "rowID", rowID);
      const localVarPath = `/v1/table/{table}/row/{rowID}`
        .replace(`{${"table"}}`, encodeURIComponent(String(table)))
        .replace(`{${"rowID"}}`, encodeURIComponent(String(rowID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (populate) {
        localVarQueryParameter["populate"] = populate;
      }

      if (condition !== undefined) {
        localVarQueryParameter["condition"] = condition;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} table
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {{ [key: string]: any; }} [condition]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [populate]
     * @param {Array<string>} [groupBy]
     * @param {string} [join]
     * @param {{ [key: string]: any; }} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRows: async (
      table: string,
      limit?: number,
      offset?: number,
      condition?: { [key: string]: any },
      fields?: Array<string>,
      populate?: Array<string>,
      groupBy?: Array<string>,
      join?: string,
      orderBy?: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'table' is not null or undefined
      assertParamExists("getRows", "table", table);
      const localVarPath = `/v1/table/{table}`.replace(
        `{${"table"}}`,
        encodeURIComponent(String(table))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (condition !== undefined) {
        localVarQueryParameter["condition"] = condition;
      }

      if (fields) {
        localVarQueryParameter["fields"] = fields;
      }

      if (populate) {
        localVarQueryParameter["populate"] = populate;
      }

      if (groupBy) {
        localVarQueryParameter["groupBy"] = groupBy;
      }

      if (join !== undefined) {
        localVarQueryParameter["join"] = join;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter["orderBy"] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchema: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/schema`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTables: async (
      limit?: number,
      offset?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/tables`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} view
     * @param {string} rowId
     * @param {Array<string>} [populate]
     * @param {{ [key: string]: any; }} [params]
     * @param {string} [join]
     * @param {Array<string>} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getViewRow: async (
      view: string,
      rowId: string,
      populate?: Array<string>,
      params?: { [key: string]: any },
      join?: string,
      fields?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'view' is not null or undefined
      assertParamExists("getViewRow", "view", view);
      // verify required parameter 'rowId' is not null or undefined
      assertParamExists("getViewRow", "rowId", rowId);
      const localVarPath = `/v1/grid/{view}/row/{rowId}`
        .replace(`{${"view"}}`, encodeURIComponent(String(view)))
        .replace(`{${"rowId"}}`, encodeURIComponent(String(rowId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (populate) {
        localVarQueryParameter["populate"] = populate;
      }

      if (params !== undefined) {
        localVarQueryParameter["params"] = params;
      }

      if (join !== undefined) {
        localVarQueryParameter["join"] = join;
      }

      if (fields) {
        localVarQueryParameter["fields"] = fields;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} view
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {{ [key: string]: any; }} [condition]
     * @param {{ [key: string]: any; }} [params]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [groupBy]
     * @param {Array<string>} [populate]
     * @param {string} [join]
     * @param {{ [key: string]: any; }} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getViewRows: async (
      view: string,
      limit?: number,
      offset?: number,
      condition?: { [key: string]: any },
      params?: { [key: string]: any },
      fields?: Array<string>,
      groupBy?: Array<string>,
      populate?: Array<string>,
      join?: string,
      orderBy?: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'view' is not null or undefined
      assertParamExists("getViewRows", "view", view);
      const localVarPath = `/v1/grid/{view}`.replace(
        `{${"view"}}`,
        encodeURIComponent(String(view))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (condition !== undefined) {
        localVarQueryParameter["condition"] = condition;
      }

      if (params !== undefined) {
        localVarQueryParameter["params"] = params;
      }

      if (fields) {
        localVarQueryParameter["fields"] = fields;
      }

      if (groupBy) {
        localVarQueryParameter["groupBy"] = groupBy;
      }

      if (populate) {
        localVarQueryParameter["populate"] = populate;
      }

      if (join !== undefined) {
        localVarQueryParameter["join"] = join;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter["orderBy"] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueExportFileToken: async (
      body: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("issueExportFileToken", "body", body);
      const localVarPath = `/v1/export/files/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {'csv' | 'xlsx'} extension
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueExportToken: async (
      extension: "csv" | "xlsx",
      body: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'extension' is not null or undefined
      assertParamExists("issueExportToken", "extension", extension);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("issueExportToken", "body", body);
      const localVarPath = `/v1/export/token/extension/{extension}`.replace(
        `{${"extension"}}`,
        encodeURIComponent(String(extension))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {'write' | 'read' | 'delete'} access
     * @param {string} table
     * @param {string} id
     * @param {string} column
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueFileAccessToken: async (
      access: "write" | "read" | "delete",
      table: string,
      id: string,
      column: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'access' is not null or undefined
      assertParamExists("issueFileAccessToken", "access", access);
      // verify required parameter 'table' is not null or undefined
      assertParamExists("issueFileAccessToken", "table", table);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("issueFileAccessToken", "id", id);
      // verify required parameter 'column' is not null or undefined
      assertParamExists("issueFileAccessToken", "column", column);
      const localVarPath = `/v1/files/token/table/{table}/id/{id}/column/{column}`
        .replace(`{${"table"}}`, encodeURIComponent(String(table)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"column"}}`, encodeURIComponent(String(column)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (access !== undefined) {
        localVarQueryParameter["access"] = access;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {MigrateRequest} migrateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    migrate: async (
      migrateRequest: MigrateRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'migrateRequest' is not null or undefined
      assertParamExists("migrate", "migrateRequest", migrateRequest);
      const localVarPath = `/v1/migrate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        migrateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openapiYaml: async (
      roleName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'roleName' is not null or undefined
      assertParamExists("openapiYaml", "roleName", roleName);
      const localVarPath = `/v1/role/{roleName}/openapi.yaml`.replace(
        `{${"roleName"}}`,
        encodeURIComponent(String(roleName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} queryName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    query: async (
      queryName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queryName' is not null or undefined
      assertParamExists("query", "queryName", queryName);
      const localVarPath = `/v1/query/{queryName}`.replace(
        `{${"queryName"}}`,
        encodeURIComponent(String(queryName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    query_2: async (
      query: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists("query_2", "query", query);
      const localVarPath = `/v1/search/location/{query}`.replace(
        `{${"query"}}`,
        encodeURIComponent(String(query))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {RawsqlRequest} rawsqlRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rawsql: async (
      rawsqlRequest: RawsqlRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rawsqlRequest' is not null or undefined
      assertParamExists("rawsql", "rawsqlRequest", rawsqlRequest);
      const localVarPath = `/v1/rawsql`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        rawsqlRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {RollbackRequest} rollbackRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rollback: async (
      rollbackRequest: RollbackRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rollbackRequest' is not null or undefined
      assertParamExists("rollback", "rollbackRequest", rollbackRequest);
      const localVarPath = `/v1/rollback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        rollbackRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} table
     * @param {string} rowID
     * @param {{ [key: string]: any; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRow: async (
      table: string,
      rowID: string,
      requestBody?: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'table' is not null or undefined
      assertParamExists("updateRow", "table", table);
      // verify required parameter 'rowID' is not null or undefined
      assertParamExists("updateRow", "rowID", rowID);
      const localVarPath = `/v1/table/{table}/row/{rowID}`
        .replace(`{${"table"}}`, encodeURIComponent(String(table)))
        .replace(`{${"rowID"}}`, encodeURIComponent(String(rowID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile: async (
      token: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists("uploadFile", "token", token);
      const localVarPath = `/v1/files/upload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile_3: async (
      token: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists("uploadFile_3", "token", token);
      const localVarPath = `/v1/multiple_files/upload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1HealthGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1InspectGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/inspect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1RawschemaGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/rawschema`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UserGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1VersionGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/version`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-qore-engine-admin-secret",
        configuration
      );

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _export(
      token: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._export(
        token,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _export_1(
      token: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._export_1(
        token,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} table
     * @param {string} column
     * @param {string} rowId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async action(
      table: string,
      column: string,
      rowId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.action(
        table,
        column,
        rowId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {AuthorizeRequest} authorizeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authorize(
      authorizeRequest: AuthorizeRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Authorize200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(
        authorizeRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} table
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRow(
      table: string,
      body: object,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRow(
        table,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} token
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(
      token: string,
      filename: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UploadFile200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(
        token,
        filename,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} table
     * @param {string} rowID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRow(
      table: string,
      rowID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Rollback200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRow(
        table,
        rowID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} token
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFile(
      token: string,
      filename: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(
        token,
        filename,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} filename
     * @param {string} id
     * @param {string} column
     * @param {string} table
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadPublicFile(
      filename: string,
      id: string,
      column: string,
      table: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadPublicFile(
        filename,
        id,
        column,
        table,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {ExecuteRequest} executeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async execute(
      executeRequest: ExecuteRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Execute200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.execute(
        executeRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllRolesAndPermissions(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAllRolesAndPermissions200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRolesAndPermissions(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMigrations(
      limit?: number,
      offset?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetMigrations200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMigrations(
        limit,
        offset,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} table
     * @param {string} rowID
     * @param {Array<string>} [populate]
     * @param {{ [key: string]: any; }} [condition]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRow(
      table: string,
      rowID: string,
      populate?: Array<string>,
      condition?: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRow(
        table,
        rowID,
        populate,
        condition,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} table
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {{ [key: string]: any; }} [condition]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [populate]
     * @param {Array<string>} [groupBy]
     * @param {string} [join]
     * @param {{ [key: string]: any; }} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRows(
      table: string,
      limit?: number,
      offset?: number,
      condition?: { [key: string]: any },
      fields?: Array<string>,
      populate?: Array<string>,
      groupBy?: Array<string>,
      join?: string,
      orderBy?: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRows200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRows(
        table,
        limit,
        offset,
        condition,
        fields,
        populate,
        groupBy,
        join,
        orderBy,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSchema(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetSchema200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSchema(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTables(
      limit?: number,
      offset?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetTables200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTables(
        limit,
        offset,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} view
     * @param {string} rowId
     * @param {Array<string>} [populate]
     * @param {{ [key: string]: any; }} [params]
     * @param {string} [join]
     * @param {Array<string>} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getViewRow(
      view: string,
      rowId: string,
      populate?: Array<string>,
      params?: { [key: string]: any },
      join?: string,
      fields?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetViewRows200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getViewRow(
        view,
        rowId,
        populate,
        params,
        join,
        fields,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} view
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {{ [key: string]: any; }} [condition]
     * @param {{ [key: string]: any; }} [params]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [groupBy]
     * @param {Array<string>} [populate]
     * @param {string} [join]
     * @param {{ [key: string]: any; }} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getViewRows(
      view: string,
      limit?: number,
      offset?: number,
      condition?: { [key: string]: any },
      params?: { [key: string]: any },
      fields?: Array<string>,
      groupBy?: Array<string>,
      populate?: Array<string>,
      join?: string,
      orderBy?: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetViewRows200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getViewRows(
        view,
        limit,
        offset,
        condition,
        params,
        fields,
        groupBy,
        populate,
        join,
        orderBy,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issueExportFileToken(
      body: object,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Authorize200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.issueExportFileToken(
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {'csv' | 'xlsx'} extension
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issueExportToken(
      extension: "csv" | "xlsx",
      body: object,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Authorize200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.issueExportToken(
        extension,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {'write' | 'read' | 'delete'} access
     * @param {string} table
     * @param {string} id
     * @param {string} column
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issueFileAccessToken(
      access: "write" | "read" | "delete",
      table: string,
      id: string,
      column: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Authorize200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.issueFileAccessToken(
        access,
        table,
        id,
        column,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {MigrateRequest} migrateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async migrate(
      migrateRequest: MigrateRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Migrate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.migrate(
        migrateRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async openapiYaml(
      roleName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.openapiYaml(
        roleName,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} queryName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async query(
      queryName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.query(
        queryName,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async query_2(
      query: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.query_2(
        query,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {RawsqlRequest} rawsqlRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rawsql(
      rawsqlRequest: RawsqlRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rawsql(
        rawsqlRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {RollbackRequest} rollbackRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rollback(
      rollbackRequest: RollbackRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Rollback200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rollback(
        rollbackRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} table
     * @param {string} rowID
     * @param {{ [key: string]: any; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRow(
      table: string,
      rowID: string,
      requestBody?: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRow(
        table,
        rowID,
        requestBody,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFile(
      token: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UploadFile200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(
        token,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFile_3(
      token: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UploadFile200Response>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile_3(
        token,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1HealthGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1HealthGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1InspectGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1InspectGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1RawschemaGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1RawschemaGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UserGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UserGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1VersionGet(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<V1VersionGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1VersionGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    }
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _export(token: string, options?: any): AxiosPromise<void> {
      return localVarFp
        ._export(token, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _export_1(token: string, options?: any): AxiosPromise<void> {
      return localVarFp
        ._export_1(token, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} table
     * @param {string} column
     * @param {string} rowId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    action(
      table: string,
      column: string,
      rowId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .action(table, column, rowId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {AuthorizeRequest} authorizeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorize(
      authorizeRequest: AuthorizeRequest,
      options?: any
    ): AxiosPromise<Authorize200Response> {
      return localVarFp
        .authorize(authorizeRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} table
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRow(
      table: string,
      body: object,
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .createRow(table, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} token
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(
      token: string,
      filename: string,
      options?: any
    ): AxiosPromise<UploadFile200Response> {
      return localVarFp
        .deleteFile(token, filename, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} table
     * @param {string} rowID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRow(
      table: string,
      rowID: string,
      options?: any
    ): AxiosPromise<Rollback200Response> {
      return localVarFp
        .deleteRow(table, rowID, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} token
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(
      token: string,
      filename: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .downloadFile(token, filename, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} filename
     * @param {string} id
     * @param {string} column
     * @param {string} table
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadPublicFile(
      filename: string,
      id: string,
      column: string,
      table: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .downloadPublicFile(filename, id, column, table, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {ExecuteRequest} executeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    execute(
      executeRequest: ExecuteRequest,
      options?: any
    ): AxiosPromise<Execute200Response> {
      return localVarFp
        .execute(executeRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRolesAndPermissions(
      options?: any
    ): AxiosPromise<GetAllRolesAndPermissions200Response> {
      return localVarFp
        .getAllRolesAndPermissions(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMigrations(
      limit?: number,
      offset?: number,
      options?: any
    ): AxiosPromise<GetMigrations200Response> {
      return localVarFp
        .getMigrations(limit, offset, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} table
     * @param {string} rowID
     * @param {Array<string>} [populate]
     * @param {{ [key: string]: any; }} [condition]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRow(
      table: string,
      rowID: string,
      populate?: Array<string>,
      condition?: { [key: string]: any },
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .getRow(table, rowID, populate, condition, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} table
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {{ [key: string]: any; }} [condition]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [populate]
     * @param {Array<string>} [groupBy]
     * @param {string} [join]
     * @param {{ [key: string]: any; }} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRows(
      table: string,
      limit?: number,
      offset?: number,
      condition?: { [key: string]: any },
      fields?: Array<string>,
      populate?: Array<string>,
      groupBy?: Array<string>,
      join?: string,
      orderBy?: { [key: string]: any },
      options?: any
    ): AxiosPromise<GetRows200Response> {
      return localVarFp
        .getRows(
          table,
          limit,
          offset,
          condition,
          fields,
          populate,
          groupBy,
          join,
          orderBy,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchema(options?: any): AxiosPromise<GetSchema200Response> {
      return localVarFp
        .getSchema(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTables(
      limit?: number,
      offset?: number,
      options?: any
    ): AxiosPromise<GetTables200Response> {
      return localVarFp
        .getTables(limit, offset, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} view
     * @param {string} rowId
     * @param {Array<string>} [populate]
     * @param {{ [key: string]: any; }} [params]
     * @param {string} [join]
     * @param {Array<string>} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getViewRow(
      view: string,
      rowId: string,
      populate?: Array<string>,
      params?: { [key: string]: any },
      join?: string,
      fields?: Array<string>,
      options?: any
    ): AxiosPromise<GetViewRows200Response> {
      return localVarFp
        .getViewRow(view, rowId, populate, params, join, fields, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} view
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {{ [key: string]: any; }} [condition]
     * @param {{ [key: string]: any; }} [params]
     * @param {Array<string>} [fields]
     * @param {Array<string>} [groupBy]
     * @param {Array<string>} [populate]
     * @param {string} [join]
     * @param {{ [key: string]: any; }} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getViewRows(
      view: string,
      limit?: number,
      offset?: number,
      condition?: { [key: string]: any },
      params?: { [key: string]: any },
      fields?: Array<string>,
      groupBy?: Array<string>,
      populate?: Array<string>,
      join?: string,
      orderBy?: { [key: string]: any },
      options?: any
    ): AxiosPromise<GetViewRows200Response> {
      return localVarFp
        .getViewRows(
          view,
          limit,
          offset,
          condition,
          params,
          fields,
          groupBy,
          populate,
          join,
          orderBy,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueExportFileToken(
      body: object,
      options?: any
    ): AxiosPromise<Authorize200Response> {
      return localVarFp
        .issueExportFileToken(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {'csv' | 'xlsx'} extension
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueExportToken(
      extension: "csv" | "xlsx",
      body: object,
      options?: any
    ): AxiosPromise<Authorize200Response> {
      return localVarFp
        .issueExportToken(extension, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {'write' | 'read' | 'delete'} access
     * @param {string} table
     * @param {string} id
     * @param {string} column
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueFileAccessToken(
      access: "write" | "read" | "delete",
      table: string,
      id: string,
      column: string,
      options?: any
    ): AxiosPromise<Authorize200Response> {
      return localVarFp
        .issueFileAccessToken(access, table, id, column, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {MigrateRequest} migrateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    migrate(
      migrateRequest: MigrateRequest,
      options?: any
    ): AxiosPromise<Migrate200Response> {
      return localVarFp
        .migrate(migrateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openapiYaml(roleName: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .openapiYaml(roleName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} queryName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    query(
      queryName: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .query(queryName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    query_2(query: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .query_2(query, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {RawsqlRequest} rawsqlRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rawsql(rawsqlRequest: RawsqlRequest, options?: any): AxiosPromise<void> {
      return localVarFp
        .rawsql(rawsqlRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {RollbackRequest} rollbackRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rollback(
      rollbackRequest: RollbackRequest,
      options?: any
    ): AxiosPromise<Rollback200Response> {
      return localVarFp
        .rollback(rollbackRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} table
     * @param {string} rowID
     * @param {{ [key: string]: any; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRow(
      table: string,
      rowID: string,
      requestBody?: { [key: string]: any },
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .updateRow(table, rowID, requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(
      token: string,
      options?: any
    ): AxiosPromise<UploadFile200Response> {
      return localVarFp
        .uploadFile(token, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile_3(
      token: string,
      options?: any
    ): AxiosPromise<Array<UploadFile200Response>> {
      return localVarFp
        .uploadFile_3(token, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1HealthGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .v1HealthGet(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1InspectGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .v1InspectGet(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1RawschemaGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .v1RawschemaGet(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UserGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .v1UserGet(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1VersionGet(options?: any): AxiosPromise<V1VersionGet200Response> {
      return localVarFp
        .v1VersionGet(options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public _export(token: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      ._export(token, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public _export_1(token: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      ._export_1(token, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} table
   * @param {string} column
   * @param {string} rowId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public action(
    table: string,
    column: string,
    rowId: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .action(table, column, rowId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {AuthorizeRequest} authorizeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authorize(
    authorizeRequest: AuthorizeRequest,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .authorize(authorizeRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} table
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createRow(table: string, body: object, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createRow(table, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} token
   * @param {string} filename
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteFile(
    token: string,
    filename: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .deleteFile(token, filename, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} table
   * @param {string} rowID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteRow(table: string, rowID: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteRow(table, rowID, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} token
   * @param {string} filename
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadFile(
    token: string,
    filename: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .downloadFile(token, filename, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} filename
   * @param {string} id
   * @param {string} column
   * @param {string} table
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadPublicFile(
    filename: string,
    id: string,
    column: string,
    table: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .downloadPublicFile(filename, id, column, table, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ExecuteRequest} executeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public execute(executeRequest: ExecuteRequest, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .execute(executeRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAllRolesAndPermissions(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getAllRolesAndPermissions(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMigrations(
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getMigrations(limit, offset, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} table
   * @param {string} rowID
   * @param {Array<string>} [populate]
   * @param {{ [key: string]: any; }} [condition]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getRow(
    table: string,
    rowID: string,
    populate?: Array<string>,
    condition?: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getRow(table, rowID, populate, condition, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} table
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {{ [key: string]: any; }} [condition]
   * @param {Array<string>} [fields]
   * @param {Array<string>} [populate]
   * @param {Array<string>} [groupBy]
   * @param {string} [join]
   * @param {{ [key: string]: any; }} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getRows(
    table: string,
    limit?: number,
    offset?: number,
    condition?: { [key: string]: any },
    fields?: Array<string>,
    populate?: Array<string>,
    groupBy?: Array<string>,
    join?: string,
    orderBy?: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getRows(
        table,
        limit,
        offset,
        condition,
        fields,
        populate,
        groupBy,
        join,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getSchema(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getSchema(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getTables(
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getTables(limit, offset, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} view
   * @param {string} rowId
   * @param {Array<string>} [populate]
   * @param {{ [key: string]: any; }} [params]
   * @param {string} [join]
   * @param {Array<string>} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getViewRow(
    view: string,
    rowId: string,
    populate?: Array<string>,
    params?: { [key: string]: any },
    join?: string,
    fields?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getViewRow(view, rowId, populate, params, join, fields, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} view
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {{ [key: string]: any; }} [condition]
   * @param {{ [key: string]: any; }} [params]
   * @param {Array<string>} [fields]
   * @param {Array<string>} [groupBy]
   * @param {Array<string>} [populate]
   * @param {string} [join]
   * @param {{ [key: string]: any; }} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getViewRows(
    view: string,
    limit?: number,
    offset?: number,
    condition?: { [key: string]: any },
    params?: { [key: string]: any },
    fields?: Array<string>,
    groupBy?: Array<string>,
    populate?: Array<string>,
    join?: string,
    orderBy?: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getViewRows(
        view,
        limit,
        offset,
        condition,
        params,
        fields,
        groupBy,
        populate,
        join,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public issueExportFileToken(body: object, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .issueExportFileToken(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {'csv' | 'xlsx'} extension
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public issueExportToken(
    extension: "csv" | "xlsx",
    body: object,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .issueExportToken(extension, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {'write' | 'read' | 'delete'} access
   * @param {string} table
   * @param {string} id
   * @param {string} column
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public issueFileAccessToken(
    access: "write" | "read" | "delete",
    table: string,
    id: string,
    column: string,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .issueFileAccessToken(access, table, id, column, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {MigrateRequest} migrateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public migrate(migrateRequest: MigrateRequest, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .migrate(migrateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} roleName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public openapiYaml(roleName: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .openapiYaml(roleName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} queryName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public query(queryName: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .query(queryName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public query_2(query: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .query_2(query, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RawsqlRequest} rawsqlRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public rawsql(rawsqlRequest: RawsqlRequest, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .rawsql(rawsqlRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RollbackRequest} rollbackRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public rollback(
    rollbackRequest: RollbackRequest,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .rollback(rollbackRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} table
   * @param {string} rowID
   * @param {{ [key: string]: any; }} [requestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateRow(
    table: string,
    rowID: string,
    requestBody?: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .updateRow(table, rowID, requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public uploadFile(token: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .uploadFile(token, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public uploadFile_3(token: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .uploadFile_3(token, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1HealthGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1HealthGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1InspectGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1InspectGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1RawschemaGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1RawschemaGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1UserGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1UserGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1VersionGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1VersionGet(options)
      .then(request => request(this.axios, this.basePath));
  }
}
