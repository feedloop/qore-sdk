---
title: Qore Client SDK

language_tabs: # must be one of https://git.io/vQNgJ
  - jsx: React
  - javascript: JavaScript

toc_footers:
  - <a href='#'>Sign up to get started hacking with Qore</a>

search: true

code_clipboard: true
---

# Introduction

Welcome to Qore Client SDK documentation page, this document will guide you to start hacking with Qore. As of now, Qore Client SDK is only accessible in JavaScript Environment, we will add more soon.

## Prerequisites

1. Node.js 12+
1. Qore account, signup [here](https://qore.feedloop.io).

## Features

### Document caching

Each read operation is cached by default, any _similar_ read request will share the same data. With qore client you might not need an additional state management.

### TypeScript Support

Qore cli can generate the schema of your project in TypeScript, meaning that you'll know what to insert and what to read from your qore client.

# Getting Started

## Install Qore CLI

> Installing via npm

```shell
npm install --global @feedloop/qore-cli
```

> Installing via yarn

```shell
yarn global add @feedloop/qore-cli
```

Install @feedloop/qore-cli globally via npm or yarn.

## Authenticate yourself

```shell
qore login
```

You will be asked to input your email & password. Choose your default project afterwards.

## Create a new project from template

```shell
qore create-project --template todo-list-typescript <your-new-project-name>
```

This command will create a new project for you, including a starter-kit project selected (in this case, todo-list-typescript) on your current working directory. This starter project includes common SDK implementations that should get you started.

Using qore javascript sdk needs a few additional steps to improve developer experience on daily basis.

## Installation

> Installing via npm

```shell
npm install @feedloop/qore-client
```

> Installing via yarn

```shell
yarn add @feedloop/qore-client
```

Install @feedloop/qore-client on your project, you may want to skip this section if you have a starter-kit project already.

> Optional: Install @feedloop/qore-react to your project.

```shell
yarn add @feedloop/qore-react
```

## Codegen

Once run, @feedloop/qore-cli codegen will give you the following files:

1. `qore-generated.ts` contains the schema of your project in typescript.
1. `qore-schema.json` contains the schema required to run qore client.
1. `qore.config.json` contains the config required to connect to your project.

> Generate required files

```shell
qore codegen
```

## Initialize

Initialize qore client with the config generated by the codegen.

```javascript
import QoreClient from "@feedloop/qore-client";
import config from "./qore.config.json";
import schema from "./qore-schema.json";

const client = new QoreClient(config);
client.init(schema);
```

```jsx
import createQoreContext from "@feedloop/qore-react";
import config from "./qore.config.json";
import schema from "./qore-schema.json";

const client = new QoreClient(config);
client.init(schema);

const qoreContext = createQoreContext(client);
// Add qore context provider to your root component.
const Root = () => {
  return (
    <qoreContext.Provider>
      <YourApp />
    </qoreContext.Provider>
  );
};
```

> Optional: TypeScript support

```typescript
import QoreClient from "@feedloop/qore-client";
import config from "./qore.config.json";
import schema from "./qore-schema.json";
import { QoreProjectSchema } from "./qore-generated";

const client = new QoreClient<QoreProjectSchema>(config);
client.init(schema);
```

Qore client initialization accepts a parameter type generated by codegen.

# Reading data

Once initialized, your project views will be accessible via the client instance. You can start reading the data of your view.

```javascript
const { data, error } = await client.views.allTasks
  .readRows({ offset: 10, limit: 10, order: "desc" })
  .toPromise();
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [{ data: allTasks, stale, error }] = qoreContext.allTasks.useListRows({
    offset: 10,
    limit: 10,
    order: "asc"
  });
  return (
    <ul>
      {allTasks.map(task => (
        <li>{task.name}</li>
      ))}
    </ul>
  );
};
```

`data` will contain rows of your `allTasks` view. In case an error occured, `data` can be null and `error` should contain the cause of error.

You can also specify `offset`, `limit` and `order` when performing a read view operation.

## Reading individual row

```javascript
const { data, error } = await client.views.allTasks
  .readRow("some-task-id")
  .toPromise();
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [{ data: someTask, stale, error }] = qoreContext.allTasks.useGetRow(
    "some-task-id"
  );
  return (
    <ul>
      {allTasks.map(task => (
        <li>{task.name}</li>
      ))}
    </ul>
  );
};
```

Oftentimes we want to get the detail of a specific row by the ID. Assuming the id is _some-task-id_, you can fetch it this way:

`data` will contain either a single row or null if an error has occured, `error` object will tell you the cause.

## Caching data

```javascript
const { data, error } = await client.views.allTasks
  .readRows(
    { offset: 10, limit: 10, order: "desc" },
    { networkPolicy: "cache-only" }
  )
  .toPromise();
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [{ data: allTasks, stale, error }] = qoreContext.allTasks.useListRows(
    {
      offset: 10,
      limit: 10,
      order: "asc"
    },
    { networkPolicy: "cache-only" }
  );
  return (
    <ul>
      {allTasks.map(task => (
        <li>{task.name}</li>
      ))}
    </ul>
  );
};
```

A qore client has an internal storage that acts as a cache that is turned on by default to minimize http request.

By setting the `networkPolicy` option to `cache-only`, you are telling qore client to only get the data from the cache instead of getting it from the server.

`networkPolicy` option accepts the following values:

| Value             | Description                                                        |
| ----------------- | ------------------------------------------------------------------ |
| cache-only        | Read data only from the cache                                      |
| network-only      | Read data only from the network                                    |
| network-and-cache | Read data from the cache first, then a network request will follow |

Reading data from `network-and-cache` may require you to subscribe to the read operation because there will be a follow up result from the network after the operation hits the cache.

<aside class="notice">
You don't need to subscribe to anything if you use the React Hooks as it does this for you internally.
</aside>

```javascript
const operation = client.views.allTasks.readRows(
  { offset: 10, limit: 10, order: "desc" },
  { networkPolicy: "cache-and-network" }
);

const subscription = operation.subscribe(({ data, error, stale }) => {
  if (data && !stale) {
    doSomething(data);
    subscription.unsubscribe();
  }
});
```

`stale` will be `true` when it hits the cache, `false` when it hits the network. Indicating that the data might be obsolete due to a follow up network request.

## Revalidating data

```javascript
const operation = client.views.allTasks.readRows(
  { offset: 10, limit: 10, order: "desc" },
  { networkPolicy: "cache-and-network" }
);

const subscription = operation.subscribe(({ data, error, stale }) => {
  doSomething(data);
});

operation.revalidate();
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [{ data: allTasks }, revalidate] = qoreContext.allTasks.useListRows(
    {
      offset: 10,
      limit: 10,
      order: "asc",
    },
    { networkPolicy: "cache-and-network" }
  );
  return (
    <>
    <button onClick={revalidate}>refresh</button>
    <ul>
      {allTasks.map((task) => (
        <li>{task.name}</li>
      ))}
    </ul>
    <>
  );
};
```

Oftentimes you want to get the most up-to-date state of your data from the network.

By calling `revalidate()`, you are asking qore client to send a `network-only` mode to your operation, giving you the most recent state of the data. Think of it as a reload button of your browser tab.

## Polling interval

```javascript
const operation = client.views.allTasks.readRows(
  { offset: 10, limit: 10, order: "desc" },
  { networkPolicy: "cache-and-network", pollInterval: 5000 }
);

const subscription = operation.subscribe(({ data, error, stale }) => {
  doSomething(data);
});
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [{ data: allTasks }, revalidate] = qoreContext.allTasks.useListRows(
    {
      offset: 10,
      limit: 10,
      order: "asc",
    },
    { networkPolicy: "cache-and-network", pollInterval: 5000 }
  );
  return (
    <>
    <button onClick={revalidate}>refresh</button>
    <ul>
      {allTasks.map((task) => (
        <li>{task.name}</li>
      ))}
    </ul>
    <>
  );
};
```

Instead of calling `operation.revalidate()` periodically, you can ask qore client to send request periodically by specifying a polling interval option in milisecond.

This operation will be refreshed every 5 seconds, a nice near-realtime effect to your users.

# Writing data

Similar to reading data, writing data is accessible from each view object.

## Insert a new row

```javascript
const newRow = await client.views.allTasks.insertRow({ ...data });
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [insertRow, status] = qoreContext.allTasks.useInsertRow();
  return (
    <button
      onClick={async () => {
        await insertRow({ ...data });
      }}
    >
      insert
    </button>
  );
};
```

Insert a data to `allTasks` view.

`data` must be compliant to the schema of the view, excluding the `id` field.

## Update a row

```javascript
await client.views.allTasks.updateRow("some-task-id", {
  ...data
});
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [updateRow, status] = qoreContext.allTasks.useUpdateRow();
  return (
    <button
      onClick={async () => {
        await updateRow("some-task-id", { ...data });
      }}
    >
      update
    </button>
  );
};
```

Update a data of `allTasks` view with an id of _some-task-id_.

`data` must be compliant to the schema of the view, excluding the `id` field.

## Add & remove relationships

```javascript
await client.views.allTasks.addRelation(taskId, {
  person: [member.id],
  links: links.map(link => link.id)
});

await client.views.allTasks.removeRelation(taskId, {
  person: [member.id]
});
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [removeRelation, status] = qoreContext.allTasks.removeRelation(taskId);
  const [addRelation, status] = qoreContext.allTasks.addRelation(taskId);
  return (
    <div>
      <button
        onClick={async () => {
          await addRelation({
            person: [member.id],
            links: links.map(link => link.id)
          });
        }}
      >
        add relation
      </button>
      <button
        onClick={async () => {
          await removeRelation({ person: [member.id] });
        }}
      >
        remove relation
      </button>
    </div>
  );
};
```

Both `addRelation` and `removeRelation` accept the `id` of the target row, followed by an object with the key being the relation name and the value is an array of reference id of the relationship.

In this example we are adding `member.id` to the relationship of a specific row on the `allTasks` view and then removing it.

## Update a row

```javascript
await client.views.allTasks.updateRow("some-task-id", {
  ...data
});
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [updateRow, status] = qoreContext.allTasks.useUpdateRow();
  return (
    <button
      onClick={async () => {
        await updateRow("some-task-id", { ...data });
      }}
    >
      update
    </button>
  );
};
```

Update a data of `allTasks` view with an id of _some-task-id_.

`data` must be compliant to the schema of the view, excluding the `id` field.

## Upload a file

```javascript
const files = await client.views.allTasks.upload(event.target.files);
await client.views.allTasks.updateRow("some-task-id", {
  ...data
  avatar: files
});
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [updateRow, status] = qoreContext.allTasks.useUpdateRow();
  const handleUpload = async event => {
    const files = await client.upload(event.target.files);
    await updateRow("some-task-id", { ...data, avatar: files });
  };
  return <input type="file" onChange={handleUpload} />;
};
```

Adding files to a row requires you to upload the file first. The file type of the uploaded files must match with the field target, unwanted file types will be ignored.

## Delete a row

```javascript
await client.views.allTasks.deleteRow("some-task-id");
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [deleteRow, status] = qoreContext.allTasks.useDeleteRow();
  return (
    <button
      onClick={async () => {
        await deleteRow("some-task-id", { ...data });
      }}
    >
      delete
    </button>
  );
};
```

Remove a data of `allTasks` view with an id of _some-task-id_.

## Trigger actions

```javascript
const rowActions = client.views.allTasks.rowActions("some-task-id");

await rowActions.archiveTask.trigger({
  someParams: "someValue"
});
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [rowActions, status] = qoreContext.allTasks.useActions("some-task-id");
  return (
    <button
      onClick={async () => {
        await rowActions.archiveTask.trigger({
          someParams: "someValue"
        });
      }}
    >
      archive task
    </button>
  );
};
```

Each qore row can have one or more action triggers, an action trigger may require parameters.

## Send form inputs

```javascript
await client.views.allTasks.forms.newTaskForm.send({
  someParams: "someValue"
});
```

```jsx
import qoreContext from "./qoreContext";

const Component = () => {
  const [forms, status] = qoreContext.allTasks.useForms();
  return (
    <button
      onClick={async () => {
        await forms.newTaskForm.send({
          someParams: "someValue"
        });
      }}
    >
      Add new task
    </button>
  );
};
```

Each qore view has one or more forms, sending forms may require parameters.

# Authenticating your user

```typescript

// give qore client a way to access user token
const client = new QoreClient({..config, getToken: () => cookies.get("token")})

const token = await client.authenticate(
  "email@yourcompany.com",
  "plain password"
);

// save token to somewhere safe
cookies.set("token", token);

// log a user out by removing the token from your storage
cookies.remove("token");
```

As you can register new users to qore, you might need to log them in to your application.

# Error handling

```typescript
const client = new QoreClient({..config, onError: (error) => {
  switch(error.code) {
    case 500:
      modal.message("An error has occured");
      break;
    case 401:
      router.push("/login");
      break;
  }
})})

```

Any error that occurs along the lifetime of a qore client will be emitted via the `onError` callback supplied during initialization.
